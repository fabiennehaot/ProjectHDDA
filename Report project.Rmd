---
title: "HDDA Project"
author: "Lisa Barbier, Klara Dewitte, Fabienne Haot, Kasimir Putseys"
date: "December 2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(gridExtra)
library(HDDAData)
library(glmnet)
library(MASS)
library(locfdr)
library(boot)
library(pROC)
```

# Research Question

# Executive Summary

# Technical Report

## Data
```{r getdata}
data("Einecke2010Kidney")
X_raw <- Einecke2010Kidney[, -1]
Y <- factor(Einecke2010Kidney[, 1], levels = c(0, 1),labels = c('accept', 'reject'))
```

## Exploration of the Data

## Hypothesis Testing 
```{r hyptest_unadjusted}
gene_data <- as.matrix(X_raw)
group <- Y
# non adjusted p-values as named vector
ttest_results <- apply(gene_data, 2, function(x) {
  t_test <- t.test(x ~ group)
  p_val <- t_test$p.value
  stat <- t_test$statistic
  df <- t_test$parameter
  z_val <- case_when(stat < 0 ~ qnorm(p_val/2), TRUE~ qnorm(1-p_val/2))
  tibble(stat = stat, p_val = p_val,z_val = z_val, df = df)})
t_stats <- bind_rows(ttest_results) %>%
  mutate(
    gene = colnames(X_raw),
    relevant = cut(z_val,
                   c(-Inf, qnorm(.025), qnorm(.975), Inf), 
                   labels = c('low', 'mid', 'high')))


ggplot(data=as.data.frame(t_stats)) + 
  geom_point(mapping = aes(x = seq_along(stat), y = stat,
                         color = relevant),size=.3)+
  labs(title = "t-statistics", x = "gene", y = "unadjusted t-statistic",
       caption = "There are more observations in the lower tail") +
  theme_bw()
table_p_nonadj <- table(t_stats$p_val < 0.05)
no_corr_genes <- t_stats %>% 
  filter(p_val < .05) %>%
  .$gene
```

There are `r as.numeric(table_p_nonadj['TRUE'])` out of 10.000 genes with p-value of 0.05.

```{r hyptest_fdr_hist}
#fdr analysis - current behaviour of p-values: uniform?
t_stats %>%
  ggplot(aes(x = p_val)) +
  geom_histogram(fill = "firebrick",breaks = seq(0, 1, .05))+
  labs(title = 'histogram of p-values')+
  theme_bw()
```

This histogram shows a distribution which is close to a uniform distribution
For the larger p-values, but with more small p-values than expected under 
a uniform distribution. The higher number of genes with small p-values indicates that some genes show a different behaviour regarding kidney rejection


```{r hyptest_fdr_padj}
# adjusted p values
fdr_level <- .1
t_stats <- t_stats %>%
  mutate(p_adj = p.adjust(p_val, method = "fdr"))

# monotonous transformation:
pp_adj <- t_stats %>%
  ggplot(aes(x = p_val, y = p_adj)) +
  geom_point(size = .3, color = 'blue') +
  geom_segment(x = 0, y = 0, xend = 1, yend = 1) +
  labs(y = "adjusted p-value (BH, 1995)") +
  theme_bw()

# right plot removes observations with high fdr 
# 8090 obs are removed when ylim .05
# 7575 when ylim .1
# plotting seems to take a while
grid.arrange(pp_adj,
             pp_adj + ylim(c(0, fdr_level)),
             ncol = 2)

# these are the genes
table_p_adj <- table(t_stats$p_adj < fdr_level)
fdr_genes <- t_stats %>%
  filter(p_adj < fdr_level)%>%
  .$gene

```

After selection still high dimensional. The genes tell us something about the rejection status through the t-tests.

```{r localfdr}
#local fdr

fdr_x <- locfdr(t_stats$z_val, plot = 3) 
```
 The probability $Pr[fdr(Z) < \alpha]$ is the probability that a non-null 
 can be detected when the nominal local fdr is set at $\alpha$
 $\alpha$ = O.1 corresponds with proportion 60%.
 Efdr = .215 means that the local fdr for a typical non-null feature is expected to be 21.5%.


 $\delta = -0.605$ indicates that the null distribution is shifted to negative values due to correlations or non-compliance with the null-hypotheses.
 $\sigma = 1.621$: standard deviation becomes larger than 1
The fact that the blue and green line differ on the left side show the signal genes for kidney rejection. We don't expect to find signal genes with high t-values.

```{r lfdr_meanfdr}
lfdr_level <- fdr_x$Efdr[1]
t_stats <- t_stats %>%
  mutate(
    lfdr = fdr_x$fdr,
    zfdr = (lfdr < lfdr_level) * z_val)

t_stats %>%
  filter(lfdr < lfdr_level) %>%
  summarize(nr_of_genes = n(), mean_fdr = mean(lfdr))
```

## Model Selection
In the next step we want the predict the rejection status using the gene expression levels. Therefore, we first start with splitting the dataset into a train (70%) and test (30%) dataset.

Hier ook nog de testset deftig scalen? maar hoe?

```{r training and test data}
set.seed(1234)
trainset <- sample(nrow(X_raw), 0.7*nrow(X_raw))
trainX <- X_raw[trainset, ]
trainX <- scale(trainX, center = TRUE, scale = TRUE)
dim(trainX) #175*10000
trainY <- Y[trainset]

testX <- X_raw[-trainset, ]
dim(testX) #75*10000
testY <- Y[-trainset]

train_data <- data.frame(trainY, trainX)
test_data <- data.frame(testY, testX)
```
Here, we will evaluate three prediction models: principal component regression (PCR), Ridge regression and Lasso regression.

# Principal compentent regression (PCR)

```{r PCR}
# Calculate PCA and extract scores
pca_X <- prcomp(trainX)
Z <- pca_X$x

## Total number of available PCs
n_PC <- ncol(Z)
n_PC
```
First, the principal components are calculated and the total number of available PC's is selected. In our case, 175 PC's are available.

```{r full PCR, cache=TRUE}
fit_data <- data.frame(trainY, Z)

## Example of PC Log. Reg. with all PCs
full_model <- suppressWarnings(glm(trainY ~ ., data = fit_data, family = "binomial"))

set.seed(1234)
full_model_cv <- suppressWarnings(cv.glm(
  data = fit_data,  glmfit = full_model,
  cost = auc, K = 10  # note: specify the auc function (from pROC) without`()`!
))

## We'll just use the raw one here
full_model_cv$delta[1] # This is the AUC for this particular model estimated by AUC
```

First we try to fit a model with all the PCs. This means we will have overfitting, as the model will predict the training dataset exactly, but this will not be reproducible to other (or the test) dataset. Here we get an area under the curve (AUC) of 0.6179526. 

```{r each PC, cache=TRUE}
## Now we'll wrap this code in a for-loop and repeat for each number of PCs
cv_auc <- vector("numeric", length = n_PC)
set.seed(1234) # seed for reproducibility
for (i in seq_len(n_PC)) {
  ## Prepare fit_data; subset number of PCs to i
  fit_data <- data.frame(trainY, Z[, 1:i, drop = FALSE])  # use drop = FALSE to avoid problems when subsetting single column
  pcr_mod <- suppressWarnings(
    glm(trainY ~ ., data = fit_data, family = "binomial")
  )
  
  ## Do 4-fold CV while suppressing Warnings and Messages
  cv <- suppressWarnings(
    suppressMessages(
      cv.glm(fit_data, pcr_mod, cost = pROC::auc, K = 4)
    )
  )
  cv_auc[i] <- cv$delta[1]
}
names(cv_auc) <- seq_along(cv_auc)
cv_auc

## Finding the optimal nr. of PCs corresponds to finding the max. AUC
optim_nPC <- names(which.max(cv_auc))
optim_nPC

plot(names(cv_auc), cv_auc, xlab = "n PCs", ylab = "AUC", type = "l")
abline(v = optim_nPC, col = "red")
```

In a second step, we loop and repeat this for each PC. This gives us the optimal number of PC's of 15, which corresponds to an AUC of  0.8221924.

# Ridge regression

# Lasso regression

## Model Evalutaion

## Conclusions


## Including Plots

